% Chapter 6: Last Conclusions

\chapter{Conclusiones} % Main chapter title

\label{Chapter6} % Reference

%-------------------------------------------------------------------------------

En este capítulo se describen las conclusiones finales alcanzadas tras el desarrollo del proyecto, así como las lecciones aprendidas durante el mismo.

\section{Consecución de los objetivos}

Los objetivos establecidos al comienzo del proyecto son:

\begin{itemize}
	\item Estudio y comprensión del problema de la búsqueda del clique de ratio máximo.
	\item Estudio e implementación del algoritmo metaheurístico \gls{GRASP} para la resolución del problema.
\end{itemize}

Y por otro lado los objetivos secundario:
\begin{itemize}
	\item Estudio de la importancia de los grafos en la vida real.
	\item Estudio de los distintos algoritmos metaheurísticos existentes.
	\item Estudio y comprensión de la complejidad computacional relacionada con la búsqueda de clique de ratio máximo.
	\item Aprendizaje del lenguaje de programación Python para el desarrollo del algoritmo metaheurístico \gls{GRASP}.
	\item Profundización y mejora en técnicas algorítmicas, de programación y de estructuras de datos para la realización de este trabajo fin de grado.
\end{itemize}

Estos objetivos se han cumplido de manera satisfactoria, puesto que se ha estudiado el estado del arte del problema del clique de ratio máximo para poder abordarlo, así como problemas relacionados como son el problema del clique de peso máximo y el clásico problema del clique máximo.
También se han estudiado las distintas familias en las que se categorizan los algoritmos metaheurísticos y en especial el algoritmo \gls{GRASP}.
Todo esto ha ayudado en la comprensión del problema y su posterior diseño e implementación.

%-------------------------------------------------------------------------------

\section{Conocimientos adquiridos}

El proceso de realización de este trabajo fin de grado ha supuesto la superación de diferentes retos los cuales han permitido adquirir muchos conocimientos sobre el desarrollo de software y la gestión de un proyecto. También se han adquirido y profundizado en conceptos sobre algoritmia y estructuras de datos para obtener soluciones mejores y más eficientes al planteamiento de problemas. Por lo tanto se destacan:

\begin{itemize}
  \item El aumento y mejora de conocimientos en el lenguaje de programación Python, usado para la implementación de este proyecto.
  \item La comprensión sobre conceptos de algoritmia y estructuras de datos, así como la mejora continua del código, enfocados en la resolución de problemas de optimización.
  \item Adquisición de conocimientos sobre heurísticas y metaheurísticas aplicadas a la resolución de problemas.
  \item Profundización en el uso de grafos en programación, así como la relación con el mundo real.
  \item El aprendizaje sobre \LaTeX, al utilizarlo para documentar el trabajo fin de grado.
\end{itemize}

\section{Líneas de desarrollo futuras}
En cuanto a las líneas de desarrollo futuras para este problema se podrían seguir las siguientes posibilidades:

En primer lugar algo que ofrece un considerable aumento en el rendimiento del código es la utilización de Cython\footnote{https://cython.org/}, mediante pequeñas modificaciones en el código para ajustarlo a su lenguaje propio, este compilador optimizado permite aumentar el  rendimiento de las funciones escritas en Python, algunas de sus características son la unificación de la mayor legibilidad del código escrito en Python con el rendimiento de C y la interactuación eficientemente con grandes conjuntos de datos mediante NumPy\footnote{https://numpy.org/}.

Y otra buena mejora en el propio código Python podría ser la implementación del procesado paralelo aprovechando el módulo concurrent.futures que ofrece Python el cuál hace uso del módulo multiprocessing, por lo tanto no se ve afectado por el \gls{GIL} \footnote{https://docs.python.org/3/glossary.html?highlight=gil\#term-global-interpreter-lock} y permite crear un pool de procesos, mediante la función ProcessPoolExecutor, para ejecutar llamadas asíncronas. Una buena opción a priori sería separar los ficheros de las instancias y que cada proceso las vaya procesando paralelamente.

%-------------------------------------------------------------------------------
